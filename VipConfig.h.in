#ifndef TH_CONFIG_H
#define TH_CONFIG_H

#include <QtGlobal>

#ifdef VIP_BUILD_LOGGING_LIB
	#define VIP_LOGGING_EXPORT Q_DECL_EXPORT
#else
	#define VIP_LOGGING_EXPORT Q_DECL_IMPORT
#endif

#ifdef VIP_BUILD_DATA_TYPE_LIB
	#define VIP_DATA_TYPE_EXPORT Q_DECL_EXPORT
#else
	#define VIP_DATA_TYPE_EXPORT Q_DECL_IMPORT
#endif

#ifdef VIP_BUILD_PLOTTING_LIB
	#define VIP_PLOTTING_EXPORT Q_DECL_EXPORT
#else
	#define VIP_PLOTTING_EXPORT Q_DECL_IMPORT
#endif

#ifdef VIP_BUILD_CORE_LIB
	#define VIP_CORE_EXPORT Q_DECL_EXPORT
#else
	#define VIP_CORE_EXPORT Q_DECL_IMPORT
#endif

#ifdef VIP_BUILD_GUI_LIB
	#define VIP_GUI_EXPORT Q_DECL_EXPORT
#else
	#define VIP_GUI_EXPORT Q_DECL_IMPORT
#endif

#ifdef VIP_BUILD_ANNOTATION_LIB
	#define VIP_ANNOTATION_EXPORT Q_DECL_EXPORT
#else
	#define VIP_ANNOTATION_EXPORT Q_DECL_IMPORT
#endif


// Try to avoid LOTS of warnings on msvc due to math constants being redefined
#if defined(_MSC_VER)
#define _USE_MATH_DEFINES 1
#include <qmath.h>
#endif


/* Version parsed out into numeric values 

The version number follow these rules:
<ul>
<li> A micro version change means that only the function/member implementations changed. 
A plugin compiled with a different micro version can still be loaded.</li>
<li> A minor version change implies a modification of function/member definition.
A plugin compiled with a different minro version can not be loaded.</li>
<li> A major version change implies a hude modification of Thermavip architecture.</li>
</ul>
*/


#define VIP_PROJECT_NAME "@PROJECT_NAME@"
#define VIP_VERSION  "@PROJECT_VERSION@"
#define VIP_MAJOR_VERSION "@PROJECT_VERSION_MAJOR@"
#define VIP_MINOR_VERSION "@PROJECT_VERSION_MINOR@"
#define VIP_MICRO_VERSION "@PROJECT_VERSION_PATCH@"


/**
Enable/disable printf function in debug/release
*/
#define VIP_ENABLE_PRINTF_DEBUG 1
#define VIP_ENABLE_PRINTF_RELEASE 0





/**
Disable printf calls if required
*/
#if defined(NDEBUG)
	#if VIP_ENABLE_PRINTF_RELEASE == 0
		#define vip_debug(...)
	#else
		#define vip_debug(...) printf(__VA_ARGS__)
	#endif
#else
	#if VIP_ENABLE_PRINTF_DEBUG == 0
		#define vip_debug(...)
	#else
		#define vip_debug(...) printf(__VA_ARGS__)
	#endif
#endif


//#define VIP_USE_LONG_DOUBLE



// __MINGW32__ doesn't seem to be properly defined, so define it.
#ifndef __MINGW32__
#if	(defined(_WIN32) || defined(__WIN32__) || defined(WIN32)) && defined(__GNUC__) && !defined(__CYGWIN__)
#define __MINGW32__
#endif
#endif

//pragma directive might be different between compilers, so define a generic VIP_PRAGMA macro.
//Use VIP_PRAGMA with no quotes around argument (ex: VIP_PRAGMA(omp parallel) and not VIP_PRAGMA("omp parallel") ).
#ifdef _MSC_VER
#define _VIP_PRAGMA(text) __pragma(text)
#else
#define _VIP_PRAGMA(text) _Pragma(#text)
#endif

#define VIP_PRAGMA(text) _VIP_PRAGMA(text)


// Forces data to be n-byte aligned (this might be used to satisfy SIMD requirements).
#if (defined __GNUC__) || (defined __PGI) || (defined __IBMCPP__) || (defined __ARMCC_VERSION)
#define VIP_ALIGN_TO_BOUNDARY(n) __attribute__((aligned(n)))
#elif (defined _MSC_VER)
#define VIP_ALIGN_TO_BOUNDARY(n) __declspec(align(n))
#elif (defined __SUNPRO_CC)
// FIXME not sure about this one:
#define VIP_ALIGN_TO_BOUNDARY(n) __attribute__((aligned(n)))
#else
#define VIP_ALIGN_TO_BOUNDARY(n) VIP_USER_ALIGN_TO_BOUNDARY(n)
#endif


// Simple function inlining
#define VIP_INLINE inline

// Strongest available function inlining
#if (defined(__GNUC__) && (__GNUC__>=4)) || defined(__MINGW32__)
#define VIP_ALWAYS_INLINE __attribute__((always_inline)) inline
#elif defined(__GNUC__)
#define VIP_ALWAYS_INLINE  inline
#elif (defined _MSC_VER) || (defined __INTEL_COMPILER)
#define VIP_ALWAYS_INLINE __forceinline
#else
#define VIP_ALWAYS_INLINE inline
#endif


// assume data are aligned
#if defined(__GNUC__) && (__GNUC__>=4 && __GNUC_MINOR__>=7)
#define VIP_RESTRICT __restrict
#define VIP_ASSUME_ALIGNED(type,ptr,out,alignment) type * VIP_RESTRICT out = (type *)__builtin_assume_aligned((ptr),alignment);
#elif defined(__GNUC__)
#define VIP_RESTRICT __restrict
#define VIP_ASSUME_ALIGNED(type,ptr,out,alignment) type * VIP_RESTRICT out = (ptr);
//on intel compiler, another way is to use #pragma vector aligned before the loop.
#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
#define VIP_RESTRICT restrict
#define VIP_ASSUME_ALIGNED(type,ptr,out,alignment) type * VIP_RESTRICT out = ptr;__assume_aligned(out,alignment);
#elif defined(__IBMCPP__)
#define VIP_RESTRICT restrict
#define VIP_ASSUME_ALIGNED(type,ptr,out,alignment) type __attribute__((aligned(alignment))) * VIP_RESTRICT out = (type __attribute__((aligned(alignment))) *)(ptr);
#elif defined(_MSC_VER)
#define VIP_RESTRICT __restrict
#define VIP_ASSUME_ALIGNED(type,ptr,out,alignment) type * VIP_RESTRICT out = ptr;
#endif




//define this macro to disable multithreading
//#define VIP_DISABLE_MULTI_THREADING

/**
* If OpenMP is enabled and VIP_DISABLE_MULTI_THREADING is not defined, define VIP_ENABLE_MULTI_THREADING
*/
#if defined(_OPENMP) && !defined(VIP_DISABLE_MULTI_THREADING)
#define VIP_ENABLE_MULTI_THREADING
#include <omp.h>

namespace detail
{
	//omp_get_num_threads broken on gcc, use a custom function
	inline size_t _omp_thread_count()
	{
		static size_t n = 0;
		if (!n)
		{
#pragma omp parallel reduction(+:n)
			n += 1;
		}
		return n;
	}
}

inline size_t vipOmpThreadCount()
{
	static size_t count = detail::_omp_thread_count();
	return count;
}

inline size_t vipOmpThreadId()
{
	return omp_get_thread_num();
}
#else
inline size_t vipOmpThreadCount()
{
	return 1;
}
inline size_t vipOmpThreadId()
{
	return 0;
}
#endif


#endif
